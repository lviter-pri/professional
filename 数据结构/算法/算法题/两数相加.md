## 两数相加

总结：

题目：

```txt
输入：l1 = [2,4,3], l2 = [5,6,4]
输出：[7,0,8]
解释：342 + 465 = 807.
示例 2：

输入：l1 = [0], l2 = [0]
输出：[0]
示例 3：

输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
输出：[8,9,9,9,0,0,0,1]
提示：

每个链表中的节点数在范围 [1, 100] 内
0 <= Node.val <= 9
题目数据保证列表表示的数字不含前导零
```

### 解答

### 方案一，最优（推荐）

总结：

1. 原地模拟竖式加法
2. 直接遍历两个链表，逐位相加，处理进位（Carry），直接构建结果链表。这能将时间复杂度压缩到极致，且不需要申请额外的字符串空间。
3. **进位逻辑 **：在循环条件中加入 `|| carry != 0` 是关键，它确保了当两个链表都遍历完，但最后一次相加仍有进位时，能正确产生一个新节点

```java
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode dummy = new ListNode(0); // 哨兵节点，用于返回头结点
        ListNode current = dummy;
        int carry = 0; // 进位标识

        // 同步遍历两个链表
        while (l1 != null || l2 != null || carry != 0) {
            int val1 = (l1 != null) ? l1.val : 0;
            int val2 = (l2 != null) ? l2.val : 0;

            int sum = val1 + val2 + carry;
            carry = sum / 10; // 更新进位

            // 创建新节点并连接
            current.next = new ListNode(sum % 10);
            current = current.next;

            // 指针后移
            if (l1 != null) l1 = l1.next;
            if (l2 != null) l2 = l2.next;
        }

        return dummy.next;
    }

}
```

### 方案二，暴力操作，性能不佳

总结：

1. 这是一个典型的**算法设计错误**。你目前的代码通过“链表 -> 字符串 -> BigInteger -> 字符串 -> 链表”进行周转，这在性能开销和空间利用率上都是**极大的浪费**，完全违背了链表处理的基本架构原则。
2. **性能损耗**：`BigInteger` 会进行昂贵的字符串解析与内部二进制转换，且频繁的字符串对象创建会触发严重的 GC。



```java
import java.math.BigInteger;

class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        if (l1 == null || l2 == null) {
            throw new IllegalArgumentException("输入链表不能为空");
        }

        // 将链表转换为字符串并校验长度
        String num1 = linkedListToString(l1);
        String num2 = linkedListToString(l2);
        if (num1.isEmpty() || num2.isEmpty() || num1.length() > 100 || num2.length() > 100) {
            throw new IllegalArgumentException("输入链表长度超出范围（最大支持100位）");
        }

        // 使用 BigInteger 避免整数溢出
        BigInteger bigNum1 = new BigInteger(num1);
        BigInteger bigNum2 = new BigInteger(num2);
        BigInteger sum = bigNum1.add(bigNum2);

        // 直接构造逆序链表，避免反转操作
        return bigIntegerToReverseLinkedList(sum);
    }


    /**
     * 将 BigInteger 转换为逆序链表
     */
    private static ListNode bigIntegerToReverseLinkedList(BigInteger num) {
        String numStr = num.toString();
        ListNode sentinel = new ListNode(0); // 哨兵节点
        ListNode current = sentinel;

        // 逆序遍历字符串，构造链表
        for (int i = numStr.length() - 1; i >= 0; i--) {
            int digit = numStr.charAt(i) - '0';
            if (digit < 0 || digit > 9) {
                throw new IllegalArgumentException("非法字符：" + numStr.charAt(i));
            }
            current.next = new ListNode(digit);
            current = current.next;
        }
        return sentinel.next;
    }

    public static String linkedListToString(ListNode head) {
        if (head == null) {
            return "";
        }

        StringBuilder sb = new StringBuilder();
        ListNode current = head;

        while (current != null) {
            if (current.val < 0 || current.val > 9) {
                throw new IllegalArgumentException("链表元素超出范围（0~9）");
            }
            sb.append(current.val);
            current = current.next;
        }

        // 返回反转后的字符串
        return sb.reverse().toString();
    }
}
```

